<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 9.2.0 (458672)"/><meta name="author" content="林"/><meta name="created" content="2019-08-22 15:13:02 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2019-09-11 12:15:50 +0000"/><title>Coroutinue协程简单实用</title></head><body><div>使用前需要引入依赖</div><div><a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/ui/coroutines-guide-ui.md#android">https://github.com/Kotlin/kotlinx.coroutines/blob/master/ui/coroutines-guide-ui.md#android</a></div><div><br/></div><div><br/></div><div><span style="font-size: 24px;">概念</span></div><div>    一些需要耗时的操作，要求调用者阻塞直到它们完成。协程提供了一种避免线程阻塞的更廉价，更可控的操作线程阻塞的操作。</div><div>    协程是通过编译技术实现的，不需要VM和OS的支持，并且协程的挂起几乎无代价，无需上下文切换。</div><div><br/></div><div><span style="font-size: 18px; font-weight: bold;">挂起函数</span>使用特殊修饰符 <span style="caret-color: rgb(255, 38, 0);"><span style="color: rgb(255, 38, 0);">suspend </span>修饰，挂起函数和普通函数类似，只是它们只能在协程和挂起函数中调用。</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div><font face="Monaco">private suspend fun method(){</font></div><div><font face="Monaco">    //to do</font></div><div><font face="Monaco">}</font></div></div><div><br/></div><div><span style="color: rgb(255, 38, 0);"><img src="Coroutinue%E5%8D%8F%E7%A8%8B%E7%AE%80%E5%8D%95%E5%AE%9E%E7%94%A8.resources/C059E1CE-AB57-46D5-AAF0-90AEA2D02F5D.jpg" height="217" width="637"/><br/></span></div><div>Job状态示意图如上</div><div><br/></div><div><span style="color: rgb(255, 38, 0);">runBlocking</span>为最高级的协程，一般为主协程。</div><div>如果直接在UI线程中调用耗时任务会产生ANR</div><div><br/></div><div><span style="color: rgb(255, 38, 0);">launch</span>声明</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div>public fun CoroutineScope.launch(</div><div>    context: CoroutineContext = EmptyCoroutineContext,</div><div>    start: CoroutineStart = CoroutineStart.DEFAULT,</div><div>    block: suspend CoroutineScope.() -&gt; Unit</div><div>): Job</div></div><div><span style="color: rgb(255, 38, 0);">CoroutinueContext</span> 是从coroutinue的运行Context。</div><div><span style="color: rgb(255, 38, 0);">CoroutinueDispatcher</span> 是协程调度器，它设置一个协程使用的一个或多个线程，协程调度器可以将协程运行在指定线程中。</div><div>常见的有如下：</div><div><span style="color: rgb(148, 32, 146);">Dispatchers.Default</span> 默认的，会在vm曾经共享线程池，线程数等于cpu的核心数，大于等于2。</div><div><span style="color: rgb(148, 32, 146);">Dispatchers.IO</span> 用于IO操作的</div><div><span style="color: rgb(148, 32, 146);">Dispatchers.Main</span> 主线程的</div><div><span style="color: rgb(148, 32, 146);">Dispatchers.UnConfined</span> 不确定的</div><div><br/></div><div>job可以使用<span style="color: rgb(4, 50, 255);">cancel( )</span>取消执行</div><div><br/></div><div>Launch同步协程测试</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div>private fun test(){</div><div>    CoroutineScope(Dispatchers.Default).launch {</div><div>        blocking()</div><div>    }</div><div>}</div><div>private fun blocking() = runBlocking{</div><div>    val job = launch {</div><div>        delay(5000)</div><div>        log("秘密")</div><div>    }</div><div>    log("5000ms你会知道一个秘密")</div><div>}</div></div><div>打印如下</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div>00:30:01.109 15954-16748/com.example.coroutinestest D/测试：: </div><div>5000ms你会知道一个秘密</div><div>00:30:06.117 15954-16748/com.example.coroutinestest D/测试：: 秘密</div></div><div><br/></div><div>async异步协程测试</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div>private fun test(){</div><div>    CoroutineScope(Dispatchers.Default).launch {</div><div>        async {</div><div>            var i = 0</div><div>            repeat(10){</div><div>                log("协程1："+(++i).toString())</div><div>                delay(200)</div><div>            }</div><div>        }</div><div>        async {</div><div>            var i = 0</div><div>            repeat(10){</div><div>                log("协程2："+(++i).toString())</div><div>                delay(200)</div><div>            }</div><div>        }</div><div>    }</div><div>}</div></div><div>打印如下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div>00:37:31.665 16290-17119/com.example.coroutinestest D/测试：: 协程1：1</div><div>00:37:31.665 16290-17120/com.example.coroutinestest D/测试：: 协程2：1</div><div>00:37:31.879 16290-17120/com.example.coroutinestest D/测试：: 协程1：2</div><div>00:37:31.879 16290-17120/com.example.coroutinestest D/测试：: 协程2：2</div><div>00:37:32.082 16290-17118/com.example.coroutinestest D/测试：: 协程1：3</div><div>...</div></div><div><br/></div><div>join( ) 等待对象协程完成指定工作才往下进行</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div>private fun test(){</div><div>    CoroutineScope(Dispatchers.Default).launch {</div><div>        val job = launch {</div><div>            delay(5000)</div><div>            log("等我完成")</div><div>        }</div><div>        log("开始")</div><div>        job.join()</div><div>        log("结束")</div><div>    }</div><div>}</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div>00:42:55.553 16300-17448/com.example.coroutinestest D/测试：: 开始</div><div>00:43:00.570 16300-17451/com.example.coroutinestest D/测试：: 等我完成</div><div>00:43:00.571 16300-17451/com.example.coroutinestest D/测试：: 结束</div></div><div><br/></div><div> 在使用<span style="color: rgb(148, 32, 146);">CoroutineStart.LAZY</span>后，需要使用<span style="color: rgb(4, 50, 255);">start( )</span>后才会开始执行</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div>private fun test(){</div><div>    CoroutineScope(Dispatchers.Default).launch {</div><div>        val job = launch(Dispatchers.Unconfined,CoroutineStart.LAZY) {</div><div>            log("等我完成")</div><div>        }</div><div>        log("开始")</div><div>        delay(5000)</div><div>        job.start()</div><div>    }</div><div>}</div></div><div><br/></div></body></html>